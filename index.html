<!DOCTYPE html>
<meta charset="utf-8" />
<script src="//d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script src="https://code.jquery.com/jquery-1.7.2.min.js"></script>
<!-- <script src="https://d3js.org/d3-color.v1.min.js"></script> -->
<!-- <script src="d3-hcg/d3-hcg.js"></script> -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.min.js"
  charset="utf-8"
></script>
<script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3.layout.cloud.js"></script>
<link rel="shortcut icon" href="/favicon.ico" />
<link
  rel="stylesheet"
  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
/>

<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

<html>
  <style type="text/css">
    @font-face {
      font-family: "Twentieth Century Medium";
      src: url("fonts/TwentiethCenturyforKenmoreMedium.ttf") format("truetype");
    }
    @font-face {
      font-family: "Twentieth Century Semi Bold";
      src: url("fonts/TwentiethCenturyforKenmoreSemibold.ttf")
        format("truetype");
    }
    @font-face {
      font-family: "Twentieth Century Light";
      src: url("fonts/TwentiethCenturyforKenmoreLight.ttf") format("truetype");
    }
    @font-face {
      font-family: "Twentieth Century Bold";
      src: url("fonts/TwentiethCenturyforKenmoreBold.ttf") format("truetype");
    }
    p.customfont {
      font-family: "Twentieth Century Medium", "Twentieth Century Semi Bold",
        "Twentieth Century Light", "Twentieth Century Bold";
    }
  </style>

  <style>
    .wcs-title {
      margin: 0;
      padding: 0px;
      text-align: center;
      position: sticky;
    }

    .subtitle {
      margin: 0;
      padding: 0px;
      text-align: center;
    }

    .line-break {
      background: #ececec;
      border-left: 6px;
      height: 100px;
    }

    .line-break-vertical {
      background: #ececec;
      width: 100%;
      height: 3px;
      margin-left: 3em auto;
      margin-right: 3em auto;
      margin-bottom: 3em auto;
    }

    #grid {
      row-gap: 100px;
    }

    #words {
      font-family: "Twentieth Century Light";
    }

    footer {
      font-family: "Twentieth Century Light";
      padding: 50px;
    }

    .square {
      height: 30px;
      width: 30px;
      border-radius: 4px;
    }

    /* Treemap styles */
    /* background: #FAF3F3 */
    #treemap {
      max-width: 100%;
      overflow: auto;
    }
    text {
      pointer-events: none;
    }
    .grandparent text {
      font-weight: bold;
      font-family: "Twentieth Century Bold";
    }
    /* .grandparent:hover text {
      color: white;
    } */
    rect {
      stroke: white;
      stroke-width: 1px;
    }
    rect.parent,
    .grandparent rect {
      stroke-width: 3px;
    }
    .grandparent:hover rect {
      fill: #e4bad4;
    }
    .children rect.parent,
    .grandparent rect {
      cursor: pointer;
    }
    .children rect.child {
      opacity: 0;
    }
    .children rect.parent {
    }
    .children:hover rect.child {
      opacity: 1;
      stroke-width: 1px;
      fill: #f6dfeb;
    }
    .children:hover rect.parent {
      opacity: 0;
    }
    .legend {
      margin-bottom: 8px !important;
    }
    .legend rect {
      stroke-width: 0px;
    }
    .legend text {
      text-anchor: middle;
      pointer-events: auto;
      font-size: 15px;
      font-family: sans-serif;
      fill: black;
    }
    .form-group {
      text-align: left;
    }
    .textdiv {
      font-family: "Twentieth Century Bold";
      font-size: 14px;
      padding: 10px;
      cursor: pointer;
      overflow: none;
    }
    .textdiv .title {
      font-family: "Twentieth Century Bold";
      font-size: 102%;
      font-weight: bold;
      margin-top: 8px;
      font-size: 17px !important;
    }
    .textdiv p {
      line-height: 15px;
      margin: 0 0 4px !important;
      padding: 0px;
      font-size: 13px !important;
    }
    /***** TREE MAP STYLES END *****/
  </style>
  <head> </head>
  <body>
    <div class="wcs-title">
      <div class="container">
        <div class="row">
          <div class="col" style="padding: 0px">
            <img
              src="images/world_globe.png"
              alt="logo"
              style="margin-bottom: 20px; margin-top: 10px"
            />
            <h1
              style="font-family: 'Twentieth Century Medium'; font-size: 48px"
            >
              World <span style="color: #95e1d3">C</span
              ><span style="color: #8ac4d0">o</span
              ><span style="color: #fce38a">l</span
              ><span style="color: #ff75a0">o</span
              ><span style="color: #845ec2">r</span> Survey
            </h1>
          </div>
        </div>
      </div>
    </div>

    <div class="subtitle">
      <div class="container">
        <div class="row">
          <div class="col" style="padding: 0px">
            <h2 style="font-family: 'Twentieth Century Light'; font-size: 24px">
              110 UNWRITTEN LANGUAGES, EACH 24 NATIVE SPEAKERS
            </h2>
          </div>
        </div>
        <div class="row">
          <div class="col" style="padding: 0px">
            <p style="font-family: 'Twentieth Century Light'; font-size: 16px">
              WCS was initiated in the late 1970s to investigate how native
              speakers around the world classify colors. Within each unwritten
              language, native speakers were asked to name each of the 330
              Munsell chips randomly. Explore the results below!
            </p>
          </div>
        </div>
        <hr />
        <!-- <div class="row">
          <div class="line-break"></div>
        </div> -->
      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col">
          <p
            style="
              text-align: center;
              color: grey;
              font-family: 'Twentieth Century Light';
            "
          >
            Click on a Munsell chip to see the word cloud update or press Play
            to see the word cloud for each color.
          </p>
        </div>
      </div>
      <!-- <div class="row">
        <div class="col-sm-6"></div>
        <div class="col-sm-6">
          <div class="col-sm-3">
             <div class="vl"></div>
          </div>
        </div>
      </div> -->
      <div class="row">
        <div class="col-sm-6">
          <div id="grid"></div>
        </div>
        <div class="col-sm-6">
          <p style="color: grey; font-family: 'Twentieth Century Light'">
            Move the slider to see words with a certain number of occurences.
          </p>
          <div class="slidecontainer">
            <input
              type="range"
              min="1"
              max="25"
              value="10"
              class="slider"
              id="wordSlider"
            />
          </div>
          <button class="btn btn-primary" id="play-button">Play</button>
          <div class="square" id="selectedSquare"></div>
          <div id="words"></div>
        </div>
      </div>

      <div class="row">
        <div class="line-break"></div>
      </div>

      <div id="treemap-title">
        <h2 style="font-family: 'Twentieth Century Light'; text-align: center">
          Explore the map below for number of distinct terms used to describe
          the 330 colors in languages in different countries
        </h2>
        <p
          style="
            font-family: 'Twentieth Century Light';
            font-size: 16px;
            padding: 0px;
            text-align: center;
          "
        >
          Note: The visualization below does not contain all the data yet
        </p>
      </div>
      <div id="treemap" style="text-align: center"></div>
    </div>

    <div class="row">
      <div class="line-break"></div>
    </div>

    <!-- Create an element where the map will take place -->
    <div style="text-align: center">
      <h2 style="font-family: 'Twentieth Century Light'; text-align: center">
        Geographic Locations of the Languages Spoken by Interviewees
      </h2>
      <p
        style="
          font-family: 'Twentieth Century Light';
          font-size: 16px;
          padding: 0px;
          text-align: center;
        "
      >
        Note: The visualization below does not contain all the data yet
      </p>
      <svg id="map" width="1000" height="800"></svg>
    </div>

    <footer class="container-fluid text-center">
      <div class="row">
        <div class="line-break"></div>
      </div>
      <div class="row">
        <div class="col-sm-12">
          <h4
            style="
              font-family: 'Twentieth Century Light';
              font-size: 24px;
              margin-bottom: 0px;
            "
          >
            SUPPORT
          </h4>
        </div>
      </div>

      <div class="row">
        <div class="col-sm-4">
          <a href="https://www.kaggle.com/jboysen/color-survey?select=dict.txt "
            >Dataset</a
          >
        </div>
        <div class="col-sm-4">
          <a href="https://www.cufonfonts.com/font/twentieth-century">Fonts</a>
        </div>
        <div class="col-sm-4">
          <a
            href="https://github.com/d3/d3-scale-chromatic/blob/master/README.md"
            >Color Grid Link TBD</a
          >
        </div>
        <div class="col-sm-4">
          <a href="https://www.jing.fm/iclipt/xbioo/">Logo</a>
        </div>
        <div class="col-sm-4">
          <a
            href="http://bl.ocks.org/guglielmo/16d880a6615da7f502116220cb551498"
            >Treemap</a
          >
        </div>
      </div>
    </footer>
  </body>
  <script src="js/loadData.js"></script>
  <!-- <script src="js/buildJSON.js"></script> -->
  <script>
    d3.queue()
      .defer(d3.csv, "data/colors.csv")
      .defer(d3.csv, "data/languages.csv")
      .defer(d3.csv, "data/language_term_dict.csv")
      .defer(d3.csv, "data/chip_term_dict.csv")
      .defer(d3.csv, "data/speakers.csv")
      .await(
        (error, mycolor, languages, langTermDict, chipTermDict, speakers) => {
          let termAbbrevTermDict = getTermAbbrevToTermDict(langTermDict);

          // var color = mycolor[Math.floor(Math.random() * 330)];
          // var colorData = getDataByColor(
          //   color["L*"],
          //   color["a*"],
          //   color["b*"],
          //   mycolor,
          //   chipTermDict,
          //   termAbbrevTermDict
          // );
          // console.log("color data for given chip ID is");
          // console.log(colorData);

          var gridData = getGridData(mycolor);
          // console.log("grid data");
          // console.log(gridData);

          var tooltip = d3
            .select("#grid")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px");

          let mouseOver = function (d) {
            tooltip.style("opacity", 1);
            d3.select(this).style("stroke", "black").style("opacity", 1);
          };

          let mouseLeave = function (d) {
            tooltip.style("opacity", 0);
            d3.select(this).style("stroke", "white").style("opacity", 1);
            if (d.click % 2 == 0) {
              console.log("even");
              d3.select(this).style("stroke", "black").style("opacity", 1);
            }
          };

          let mouseMove = function (d) {
            tooltip
              .html(
                "Cell Color <br>L*:  " +
                  d.color.l +
                  "<br>a*: " +
                  d.color.a +
                  "<br>b*: " +
                  d.color.b
              )
              .style("left", d3.mouse(this)[0] + 70 + "px")
              .style("top", d3.mouse(this)[1] + "px");
            d3.select(this).style("stroke", "black").style("opacity", 1);
          };

          var grid = d3
            .select("#grid")
            .append("svg")
            .attr("width", "600px")
            .attr("height", "800px");
          // .call(
          //   d3.zoom().on("zoom", function () {
          //     svg.attr("transform", d3.event.transform);
          //   })
          // );

          //********************************MOVABLE CIRCLES TEST******************************
          //https://www.d3-graph-gallery.com/graph/circularpacking_template.html
          // var node = grid
          //   .append("g")
          //   .selectAll("circle")
          //   .data(gridData[0])
          //   .enter()
          //   .append("circle")
          //   .attr("class", "node")
          //   .attr("r", function (d) {
          //     console.log(d);
          //     console.log(Math.random() * 100);
          //     return Math.random() * 100;
          //   })
          //   .attr("cx", 600 / 2)
          //   .attr("cy", 1000 / 2)
          //   .style("fill", function (d) {
          //     return d.color;
          //   })
          //   .style("fill-opacity", 0.8)
          //   .attr("stroke", "black")
          //   .style("stroke-width", 1);

          // // Features of the forces applied to the nodes:
          // var simulation = d3
          //   .forceSimulation()
          //   .force(
          //     "center",
          //     d3
          //       .forceCenter()
          //       .x(600 / 2)
          //       .y(1000 / 2)
          //   ) // Attraction to the center of the svg area
          //   .force("charge", d3.forceManyBody().strength(0.1)) // Nodes are attracted one each other of value is > 0
          //   .force(
          //     "collide",
          //     d3
          //       .forceCollide()
          //       .strength(0.2)
          //       .radius(function (d) {
          //         return Math.random() * 100;
          //       })
          //       .iterations(1)
          //   ); // Force that avoids circle overlapping

          // // Apply these forces to the nodes and update their positions.
          // // Once the force algorithm is happy with positions ('alpha' value is low enough), simulations will stop.
          // simulation.nodes(gridData[0]).on("tick", function (d) {
          //   node
          //     .attr("cx", function (d) {
          //       return d.x;
          //     })
          //     .attr("cy", function (d) {
          //       return d.y;
          //     });
          // });
          //********************************MOVABLE CIRCLES TEST******************************
          var playButton = d3.select("#play-button");
          var moving = false;

          // console.log("chipTermDict", mycolor);

          var currentColor = getDataByColor(
            gridData[0][0].color.l,
            gridData[0][0].color.a,
            gridData[0][0].color.b,
            mycolor,
            chipTermDict,
            termAbbrevTermDict
          );

          console.log("currentcolor", currentColor);

          var row = grid
            .selectAll(".row")
            .data(gridData)
            .enter()
            .append("g")
            .attr("class", "row");

          var column = row
            .selectAll(".square")
            .data(function (d) {
              return d;
            })
            .enter()
            .append("rect")
            .attr("class", "square")
            .attr("x", function (d) {
              return d.x;
            })
            .attr("y", function (d) {
              return d.y;
            })
            .attr("width", function (d) {
              return d.width;
            })
            .attr("height", function (d) {
              return d.height;
            })
            .attr("padding", function (d) {
              return "10px";
            })
            .style("fill", function (d) {
              return d.color;
            })
            .style("stroke", "white")
            .attr("rx", 4)
            .attr("ry", 4)
            .style("stroke-width", 2)
            .on("mouseover", mouseOver)
            .on("mousemove", mouseMove)
            .on("mouseout", mouseLeave)
            .on("click", function (d) {
              console.log(d.click);
              d.click++;
              if (d.click % 1 == 0) {
                console.log("odd");
                d3.select(this).style("stroke", "white").style("opacity", 1);
              }
              if (d.click % 2 == 0) {
                console.log("even");
                d3.select(this).style("stroke", "black").style("opacity", 1);
              }
              currentColor = getDataByColor(
                d.color.l,
                d.color.a,
                d.color.b,
                mycolor,
                chipTermDict,
                termAbbrevTermDict
              );
              var updatedWords = getListofTerms(currentColor.all_terms);
              updateWordMap(updatedWords);
            });

          playButton.on("click", function () {
            var button = d3.select(this);
            if (button.text() == "Pause") {
              moving = false;
              clearInterval(timer);
              // timer = 0;
              button.text("Play");
            } else {
              moving = true;
              timer = setInterval(step, 3000);
              button.text("Pause");
            }
            console.log("Slider moving: " + moving);
          });

          function step() {
            var newChipID = parseInt(currentColor.chip_id) + 1;

            if (newChipID <= 330) {
              var newL = mycolor.find((d) => d["chip_id"] == newChipID)["L*"];
              var newA = mycolor.find((d) => d["chip_id"] == newChipID)["a*"];
              var newB = mycolor.find((d) => d["chip_id"] == newChipID)["b*"];

              currentColor = getDataByColor(
                newL,
                newA,
                newB,
                mycolor,
                chipTermDict,
                termAbbrevTermDict
              );

              updateWordMap(getListofTerms(currentColor.all_terms));
              d3.select("#selectedSquare")
                .style("stroke", "black")
                .style("opacity", 1)
                .style(
                  "background-color",
                  d3.lab(
                    parseFloat(currentColor["L*"]),
                    parseFloat(currentColor["a*"]),
                    parseFloat(currentColor["b*"]),
                    (opacity = 1)
                  )
                );
            } else {
              moving = false;
              currentValue = 0;
              clearInterval(timer);
              // timer = 0;
              playButton.text("Play");
              console.log("Slider moving: " + moving);
            }
          }

          //**********************************WORD CLOUD*******************************

          var width = 600;
          var height = 700;

          var word_cloud = d3
            .select("#words")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

          var colorWords = getListofTerms(currentColor.all_terms);

          var layout = d3.layout
            .cloud()
            .size([width, height])
            .words(
              colorWords.map(function (d) {
                // console.log(
                //   "selection",
                //   d3.select("#wordSlider").property("value")
                // );
                // console.log(d);
                // if (d.count <= d3.select("#wordSlider").property("value")) {
                //   console.log("inside the if", d);
                return {
                  text: d.term,
                  size: d.count,
                };
                // }
              })
            )
            .padding(5)
            .fontSize(function (d) {
              // binning font size by count; discuss in write up
              // console.log("later d", d);
              if (d.size <= 5) {
                return 10;
              } else if (d.size <= 10) {
                return 20;
              } else if (d.size <= 15) {
                return 30;
              } else if (d.size <= 20) {
                return 40;
              } else {
                return 50;
              }
            })
            .on("end", draw);
          layout.start();

          function draw(words) {
            word_cloud
              .append("g")
              .attr(
                "transform",
                "translate(" +
                  layout.size()[0] / 2 +
                  "," +
                  layout.size()[1] / 2 +
                  ")"
              )
              .selectAll("text")
              .data(words)
              .enter()
              .append("text")
              .style("font-size", function (d) {
                return d.size + "px";
              })
              .attr("text-anchor", "middle")
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
              })
              .text(function (d) {
                return d.text;
              });
          }

          function updateWordMap(newWords) {
            colorWords = newWords;
            layout
              .size([width, height])
              .words(
                newWords.map(function (d) {
                  return {
                    text: d.term,
                    size: d.count,
                  };
                })
              )
              .padding(5)
              .fontSize(function (d) {
                if (d.size <= 5) {
                  return 10;
                } else if (d.size <= 10) {
                  return 20;
                } else if (d.size <= 15) {
                  return 30;
                } else if (d.size <= 20) {
                  return 40;
                } else {
                  return 50;
                }
              })
              .on("end", updateCloud);
            layout.start();
          }

          function updateCloud(colorWords) {
            word_cloud.selectAll("text").remove();
            word_cloud
              .append("g")
              .attr(
                "transform",
                "translate(" +
                  layout.size()[0] / 2 +
                  "," +
                  layout.size()[1] / 2 +
                  ")"
              )
              .selectAll("text")
              .data(colorWords)
              .enter()
              .append("text")
              .transition()
              .duration(10)
              .style("font-size", function (d) {
                return d.size + "px";
              })
              .attr("text-anchor", "middle")
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
              })
              .text(function (d) {
                return d.text;
              });
          }
          d3.select("#wordSlider").on("change", function (d) {
            console.log(d3.select(this).property("value"));

            var selectedCount = d3.select(this).property("value");

            var filteredData = getListofTerms(currentColor.all_terms);

            var filteredWords = filteredData.filter(function (d) {
              if (d.count <= selectedCount) {
                return d;
              }
            });
            console.log("filteredWords:", filteredWords);
            updateWordMap(filteredWords);
          });
        }
      );

    //**********************************END WORD CLOUD*******************************

    /************** WORLD MAP START *******************/
    // The svg
    var map = d3
        .select("#map")
        .append("svg")
        .attr("width", 1000)
        .attr("height", 800),
      width = +map.attr("width"),
      height = +map.attr("height");
    // debugger;
    // Map and projection
    var path = d3.geoPath();
    var projection = d3
      .geoMercator()
      .scale(150)
      .center([0, 20])
      .translate([width / 2, height / 2]);

    // Data and color scale
    var data = d3.map();
    var colorScale = d3
      .scaleThreshold()
      .domain([10, 25, 50, 75, 100, 125, 150, 175, 200])
      .range(d3.schemeBlues[7]);

    // Load external data and boot
    d3.queue()
      .defer(
        d3.json,
        "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
      )
      .defer(d3.csv, "data/male_female_ratio.csv", function (d) {
        data.set(d.code, +d.pop);
      })
      .await(ready);

    function ready(error, topo) {
      let mouseOver = function (d) {
        d3.selectAll(".Country")
          .transition()
          .duration(200)
          .style("opacity", 0.5);
        d3.select(this)
          .transition()
          .duration(200)
          .style("opacity", 1)
          .style("stroke", "black");
      };

      let mouseLeave = function (d) {
        d3.selectAll(".Country")
          .transition()
          .duration(200)
          .style("opacity", 0.8);
        d3.select(this)
          .transition()
          .duration(200)
          .style("stroke", "transparent");
      };

      // Draw the map
      map
        .append("g")
        .selectAll("path")
        .data(topo.features)
        .enter()
        .append("path")
        // draw each country
        .attr("d", d3.geoPath().projection(projection))
        // set the color of each country
        .attr("fill", function (d) {
          d.total = data.get(d.id) || 0;
          return colorScale(d.total);
        })
        .style("stroke", "transparent")
        .attr("class", function (d) {
          return "Country";
        })
        .style("opacity", 0.8)
        .on("mouseover", mouseOver)
        .on("mouseleave", mouseLeave);
    }
    /************** WORLD MAP END *******************/
    /********************** TREE MAP *********************/
    var treemap = document.getElementById("treemap");
    var divWidth = treemap.offsetWidth;
    var margin = { top: 30, right: 0, bottom: 20, left: 0 },
      width = divWidth / 1.15,
      height = 600 - margin.top - margin.bottom,
      formatNumber = d3.format(","),
      transitioning;
    // sets x and y scale to determine size of visible boxes
    var x = d3.scaleLinear().domain([0, width]).range([0, width]);
    var y = d3.scaleLinear().domain([0, height]).range([0, height]);
    var treemap = d3
      .treemap()
      .size([width, height])
      .paddingInner(0)
      .round(false);
    var svg = d3
      .select("#treemap")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.bottom + margin.top)
      .style("margin-left", -margin.left + "px")
      .style("margin.right", -margin.right + "px")
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .style("shape-rendering", "crispEdges");
    var grandparent = svg.append("g").attr("class", "grandparent");
    grandparent
      .append("rect")
      .attr("y", -margin.top)
      .attr("width", width)
      .attr("height", margin.top);
    // .attr("fill", "#bbbbbb");
    grandparent
      .append("text")
      .attr("x", 6)
      .attr("y", 6 - margin.top)
      .attr("dy", ".75em");

    // load the data used for the treemap
    d3.json("data/treemap_terms.json", (data) => {
      debugger;
      var root = d3.hierarchy(data);
      // console.log("root is", root);
      treemap(
        root
          .sum((d) => d.value)
          .sort((a, b) => b.height - a.height || b.value - a.value)
      );
      display(root);
      // display((d) => {

      // });
      function display(d) {
        // write text into grandparent
        // and activate click's handler
        grandparent
          .datum(d.parent)
          .on("click", transition)
          .select("text")
          .text(name(d));

        // grandparent color
        grandparent
          .datum(d.parent)
          .select("rect")
          .attr("fill", function () {
            return "#FAF3F3";
          });
        var g1 = svg
          .insert("g", ".grandparent")
          .datum(d)
          .attr("class", "depth");
        var g = g1.selectAll("g").data(d.children).enter().append("g");
        // add class and click handler to all g's with children
        g.filter(function (d) {
          return d.children;
        })
          .classed("children", true)
          .on("click", transition);
        g.selectAll(".child")
          .data(function (d) {
            return d.children || [d];
          })
          .enter()
          .append("rect")
          .attr("class", "child")
          .call(rect);
        // add title to parents
        g.append("rect")
          .attr("class", "parent")
          .call(rect)
          .append("title")
          .text(function (d) {
            return d.data.name;
          });
        /* Adding a foreign object instead of a text object, allows for text wrapping */
        g.append("foreignObject")
          .call(rect)
          .attr("class", "foreignobj")
          .append("xhtml:div")
          .attr("dy", ".75em")
          .html(function (d) {
            debugger;
            return (
              "" +
              '<p class="title"> ' +
              (d.data.type != "Language" ? "" : "Language: ") +
              d.data.name +
              "</p>" +
              (d.data.type == "Country" || d.data.type == "Continent"
                ? "<p><strong style='font-size:15px'>" +
                  formatNumber(d.data.language_count) +
                  "</strong> languages represented</p>"
                : "") +
              (d.data.type != "Term"
                ? "<p><strong style='font-size:15px'>" +
                  formatNumber(d.value) +
                  "</strong> distinct terms used</p>"
                : "")
            );
          })
          .attr("class", "textdiv"); //textdiv class allows us to style the text easily with CSS
        function transition(d) {
          if (transitioning || !d) return;
          transitioning = true;
          var g2 = display(d),
            t1 = g1.transition().duration(650),
            t2 = g2.transition().duration(650);
          // Update the domain only after entering new elements.
          x.domain([d.x0, d.x1]);
          y.domain([d.y0, d.y1]);
          // Enable anti-aliasing during the transition.
          svg.style("shape-rendering", null);
          // Draw child nodes on top of parent nodes.
          svg.selectAll(".depth").sort(function (a, b) {
            return a.depth - b.depth;
          });
          // Fade-in entering text.
          g2.selectAll("text").style("fill-opacity", 0);
          g2.selectAll("foreignObject div").style("display", "none");
          /*added*/
          // Transition to the new view.
          t1.selectAll("text").call(text).style("fill-opacity", 0);
          t2.selectAll("text").call(text).style("fill-opacity", 1);
          t1.selectAll("rect").call(rect);
          t2.selectAll("rect").call(rect);
          /* Foreign object */
          t1.selectAll(".textdiv").style("display", "none");
          /* added */
          t1.selectAll(".foreignobj").call(foreign);
          /* added */
          t2.selectAll(".textdiv").style("display", "block");
          /* added */
          t2.selectAll(".foreignobj").call(foreign);
          /* added */
          // Remove the old node when the transition is finished.
          t1.on("end.remove", function () {
            this.remove();
            transitioning = false;
          });
        }
        return g;
      }
      function text(text) {
        text
          .attr("x", function (d) {
            return x(d.x) + 6;
          })
          .attr("y", function (d) {
            return y(d.y) + 6;
          });
      }
      function rect(rect) {
        rect
          .attr("x", function (d) {
            return x(d.x0);
          })
          .attr("y", function (d) {
            return y(d.y0);
          })
          .attr("width", function (d) {
            return x(d.x1) - x(d.x0);
          })
          .attr("height", function (d) {
            return y(d.y1) - y(d.y0);
          })
          .attr("fill", function (d) {
            return "#FAF3F3";
          });
      }
      function foreign(foreign) {
        /* added */
        foreign
          .attr("x", function (d) {
            return x(d.x0);
          })
          .attr("y", function (d) {
            return y(d.y0);
          })
          .attr("width", function (d) {
            return x(d.x1) - x(d.x0);
          })
          .attr("height", function (d) {
            return y(d.y1) - y(d.y0);
          });
      }
      function name(d) {
        // debugger;
        return (
          breadcrumbs(d) +
          (d.parent
            ? " -  Click to zoom out"
            : " - Click inside square to zoom in")
        );
      }
      function breadcrumbs(d) {
        var res = "";
        var sep = " > ";
        d.ancestors()
          .reverse()
          .forEach(function (i) {
            res +=
              (i.data.type == "Language" ? "Language: " : "") +
              i.data.name +
              sep;
          });
        return res
          .split(sep)
          .filter(function (i) {
            return i !== "";
          })
          .join(sep);
      }
    });
  </script>
</html>
